% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/RcppExports.R
\name{getSequencesWithEndPhenx}
\alias{getSequencesWithEndPhenx}
\title{Get Sequences With Specific End Phenx}
\usage{
getSequencesWithEndPhenx(
  df_dbMart,
  bitShift,
  lengthOfPhenx,
  lowerBucketThresholds,
  endPhenx,
  includeCorBuckets = FALSE,
  minDuration = 0L,
  storeSeqDuringCreation = FALSE,
  outputDir = "",
  outputFilePrefix = "",
  numOfThreads = 1L,
  removeSparseSequences = TRUE,
  sparsityValue = 0.05,
  createTemporalBuckets = FALSE,
  durationSparsity = FALSE,
  durationSparsityValue = 0,
  removeSparseTemporalBuckets = FALSE,
  patIdLength = 7L,
  returnDuration = TRUE,
  durationPeriods = 30.437,
  daysForCoOoccurence = 14L,
  returnSummary = FALSE,
  summaryOnPatientLevel = FALSE,
  returnCandidateDataFrame = TRUE
)
}
\arguments{
\item{df_dbMart}{The data frame that stores the data mart.}

\item{bitShift}{Integer, the number of bits used to shift the duration into sequnceID.}

\item{lengthOfPhenx}{describes the number of digits that represents a phenx in the sequence.}

\item{lowerBucketThresholds}{the lower thresholds for the temporal buckets, that are stored when the includeCorBuckets flag is set.}

\item{endPhenx}{IntegerVector, contains the phenx that sequences should end with.}

\item{includeCorBuckets}{Boolean, flag to control if the R data frame that is returned should contain columns for for the endPhenx and the buckets set in lowerBucketThresholds}

\item{minDuration}{the minimum duration a sequence must have, for j to be considered a candidate. Not Implemented at the moment!}

\item{storeSeqDuringCreation}{Boolean parameter to control if the duration should be included in the sequence ID during creation, DEFAULT = FALSE.}

\item{outputDir}{The path as string to the directory where the sequences should be stored.}

\item{outputFilePrefix}{The string file prefix for the patient files storing the sequences.}

\item{numOfThreads}{The number of threads that should be used during sequencing.}

\item{removeSparseSequences}{Boolean parameter to control if the sparsity should be applied.}

\item{sparsityValue}{The numeric value for the sparsity. DEFAULT = 0.05.}

\item{createTemporalBuckets}{Boolean flag if the the the sequences should be split up in dynamic buckets. Number of buckets min(4, max_duration(sequence)).}

\item{durationSparsity}{Boolean flag to control if sparse sequences should be removed considering the duration periods of a sequence.}

\item{durationSparsityValue}{Numeric value.}

\item{removeSparseTemporalBuckets}{Boolean, to control if the sparsity should be applied on the dynamic temporal buckets.}

\item{patIdLength}{Integer, describes the number of digits that are used for the patient number.}

\item{returnDuration}{Boolean, controls if the data frame that is returns contains.}

\item{durationPeriods}{Numeric, Upper threshold, stores the number of day in the time period, e.g. 30.471 for months, 364.25 for years.}

\item{daysForCoOoccurence}{Integer, sets the upper threshold for the sequence duration so that they are counted as co-occurrence (meaning a duration of 0).}

\item{returnSummary}{Boolean, if return a summary of the sequences instead of the sequences}

\item{summaryOnPatientLevel}{bool, that defines if the summary should be on the patient level (counting occurrences for each patient) or on the dbMart level}

\item{returnCandidateDataFrame}{Boolean to controll is a candidate dataframe should be returned, if returnSummary and returnCandidateDataFrame are both false the default sequence dataframe is returned}
}
\value{
The sequences as data frame.
}
\description{
Function to extract all transitive sequences that end with given endPhenxs.
}
